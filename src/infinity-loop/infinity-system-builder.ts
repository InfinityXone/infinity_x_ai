import { type ProcessedThought, type Component } from './thought-processor.ts';
import fs from 'fs/promises';
import path from 'path';

/**
 * INFINITY SYSTEM BUILDER
 * Builds actual systems from processed quantum thoughts
 */
export class InfinitySystemBuilder {
  private outputDir: string;
  private systemsBuilt: number = 0;

  constructor() {
    this.outputDir = path.join(process.cwd(), 'infinity-output', 'generated-systems');
  }

  /**
   * Build system from processed thought
   */
  async buildFromThought(thought: ProcessedThought): Promise<BuildResult> {
    console.log(`\nüèóÔ∏è  Building system from thought (Priority: ${thought.priority})...`);

    const systemName = this.generateSystemName(thought);
    const systemPath = path.join(this.outputDir, systemName);

    await fs.mkdir(systemPath, { recursive: true });

    let componentsCreated = 0;
    let filesGenerated = 0;

    // Build components
    for (const component of thought.components) {
      try {
        const filePath = await this.buildComponent(component, systemPath);
        if (filePath) {
          componentsCreated++;
          filesGenerated++;
          console.log(`   ‚úÖ Created: ${component.name}`);
        }
      } catch (error: any) {
        console.log(`   ‚ö†Ô∏è  Skipped: ${component.name} (${error.message})`);
      }
    }

    // Create system configuration
    await this.createSystemConfig(thought, systemPath);
    filesGenerated++;

    // Create README
    await this.createReadme(thought, systemPath);
    filesGenerated++;

    this.systemsBuilt++;

    console.log(`\n‚úÖ System built: ${systemName}`);
    console.log(`   - Components: ${componentsCreated}`);
    console.log(`   - Files: ${filesGenerated}`);

    return {
      systemName,
      systemPath,
      componentsCreated,
      filesGenerated,
      systemsBuilt: this.systemsBuilt
    };
  }

  /**
   * Generate system name from thought
   */
  private generateSystemName(thought: ProcessedThought): string {
    const timestamp = Date.now();
    const level = thought.original.evolutionLevel;
    return `system-L${level}-${timestamp}`;
  }

  /**
   * Build individual component
   */
  private async buildComponent(component: Component, systemPath: string): Promise<string> {
    const fileName = this.toKebabCase(component.name) + '.ts';
    const filePath = path.join(systemPath, 'src', fileName);

    await fs.mkdir(path.dirname(filePath), { recursive: true });

    const code = this.generateComponentCode(component);
    await fs.writeFile(filePath, code, 'utf-8');

    return filePath;
  }

  /**
   * Generate component code
   */
  private generateComponentCode(component: Component): string {
    const className = component.name.replace(/\s+/g, '');

    return `/**
 * ${component.name}
 * ${component.description}
 * 
 * Generated by Infinity System Builder
 * Type: ${component.type}
 */
export class ${className} {
  private initialized: boolean = false;

  constructor() {
    console.log('Initializing ${className}...');
  }

  /**
   * Initialize the ${component.type}
   */
  async initialize(): Promise<void> {
    if (this.initialized) {
      console.log('${className} already initialized');
      return;
    }

    console.log('${className} initializing...');
    
    // TODO: Implement initialization logic
    
    this.initialized = true;
    console.log('‚úÖ ${className} initialized');
  }

  /**
   * Execute primary function
   */
  async execute(input: any): Promise<any> {
    if (!this.initialized) {
      await this.initialize();
    }

    console.log('${className} executing...');
    
    // TODO: Implement execution logic
    
    return {
      status: 'success',
      component: '${className}',
      timestamp: new Date().toISOString()
    };
  }

  /**
   * Cleanup and shutdown
   */
  async shutdown(): Promise<void> {
    console.log('${className} shutting down...');
    this.initialized = false;
  }
}
`;
  }

  /**
   * Create system configuration
   */
  private async createSystemConfig(thought: ProcessedThought, systemPath: string): Promise<void> {
    const config = {
      name: path.basename(systemPath),
      version: '1.0.0',
      evolutionLevel: thought.original.evolutionLevel,
      priority: thought.priority,
      complexity: thought.complexity,
      components: thought.components.map(c => ({
        name: c.name,
        type: c.type,
        file: `src/${this.toKebabCase(c.name)}.ts`
      })),
      architecturePatterns: thought.architecturePatterns,
      generated: new Date().toISOString()
    };

    const configPath = path.join(systemPath, 'system-config.json');
    await fs.writeFile(configPath, JSON.stringify(config, null, 2), 'utf-8');
  }

  /**
   * Create README for system
   */
  private async createReadme(thought: ProcessedThought, systemPath: string): Promise<void> {
    const readme = `# ${path.basename(systemPath)}

## Overview
Generated by Infinity Loop Orchestrator  
Evolution Level: ${thought.original.evolutionLevel}  
Priority: ${thought.priority}  
Complexity: ${thought.complexity}

## Components
${thought.components.map(c => `- **${c.name}** (${c.type}): ${c.description}`).join('\n')}

## Architecture Patterns
${thought.architecturePatterns.map(p => `- ${p}`).join('\n')}

## Actionables
${thought.actionables.slice(0, 10).map((a, i) => `${i + 1}. ${a}`).join('\n')}

## Original Insight
\`\`\`
${thought.original.insight.slice(0, 1000)}...
\`\`\`

---
*Generated: ${new Date().toISOString()}*
`;

    const readmePath = path.join(systemPath, 'README.md');
    await fs.writeFile(readmePath, readme, 'utf-8');
  }

  /**
   * Convert to kebab-case
   */
  private toKebabCase(str: string): string {
    return str
      .replace(/([a-z])([A-Z])/g, '$1-$2')
      .replace(/\s+/g, '-')
      .toLowerCase();
  }

  /**
   * Get total systems built
   */
  getSystemsBuilt(): number {
    return this.systemsBuilt;
  }
}

export interface BuildResult {
  systemName: string;
  systemPath: string;
  componentsCreated: number;
  filesGenerated: number;
  systemsBuilt: number;
}
