import * as fs from 'fs/promises';
import * as path from 'path';
import { Document } from './document-evolution-engine.ts';
import { ConceptNode, TaxonomyCategory } from './ai-integration-layer.ts';

export interface TaxonomyNode {
  id: string;
  name: string;
  type: 'root' | 'category' | 'subcategory' | 'concept';
  parentId?: string;
  children: string[];
  level: number;
  description: string;
  documentCount: number;
  conceptCount: number;
  metadata: {
    created: Date;
    lastUpdated: Date;
    autoGenerated: boolean;
    version: number;
  };
}

export interface TaxonomyRelationship {
  source: string;
  target: string;
  type: 'parent-child' | 'sibling' | 'related' | 'cross-reference';
  strength: number;
}

export interface TaxonomyEvolution {
  timestamp: Date;
  action: 'created' | 'updated' | 'merged' | 'split' | 'archived';
  nodeId: string;
  previousState?: any;
  newState: any;
  reasoning: string;
}

export interface KnowledgeGraph {
  nodes: Map<string, TaxonomyNode>;
  relationships: TaxonomyRelationship[];
  depth: number;
  totalNodes: number;
  totalConcepts: number;
}

export class TaxonomyManager {
  private taxonomyTree: Map<string, TaxonomyNode>;
  private relationships: TaxonomyRelationship[];
  private evolutionHistory: TaxonomyEvolution[];
  private outputDir: string;
  private autoEvolve: boolean;

  constructor() {
    this.taxonomyTree = new Map();
    this.relationships = [];
    this.evolutionHistory = [];
    this.outputDir = './infinity-output/evolution-docs/taxonomy';
    this.autoEvolve = true;
  }

  async initialize(): Promise<void> {
    await fs.mkdir(this.outputDir, { recursive: true });
    await fs.mkdir(path.join(this.outputDir, 'snapshots'), { recursive: true });
    await fs.mkdir(path.join(this.outputDir, 'graphs'), { recursive: true });

    // Create root node
    const root: TaxonomyNode = {
      id: 'root',
      name: 'Knowledge Base',
      type: 'root',
      children: [],
      level: 0,
      description: 'Root of all knowledge taxonomy',
      documentCount: 0,
      conceptCount: 0,
      metadata: {
        created: new Date(),
        lastUpdated: new Date(),
        autoGenerated: false,
        version: 1
      }
    };

    this.taxonomyTree.set('root', root);

    // Load existing taxonomy if available
    await this.loadTaxonomy();

    console.log('üìö Taxonomy Manager initialized');
    console.log(`   Nodes: ${this.taxonomyTree.size}`);
    console.log(`   Relationships: ${this.relationships.length}`);
    console.log(`   Auto-evolve: ${this.autoEvolve ? 'enabled' : 'disabled'}\n`);
  }

  async createCategory(
    name: string,
    parentId: string = 'root',
    description: string = ''
  ): Promise<TaxonomyNode> {
    const categoryId = `cat-${name.toLowerCase().replace(/\s+/g, '-')}-${Date.now()}`;

    console.log(`üìÅ Creating category: ${name}`);
    console.log(`   Parent: ${parentId}`);

    const parent = this.taxonomyTree.get(parentId);
    if (!parent) {
      throw new Error(`Parent node ${parentId} not found`);
    }

    const category: TaxonomyNode = {
      id: categoryId,
      name,
      type: parent.type === 'category' ? 'subcategory' : 'category',
      parentId,
      children: [],
      level: parent.level + 1,
      description,
      documentCount: 0,
      conceptCount: 0,
      metadata: {
        created: new Date(),
        lastUpdated: new Date(),
        autoGenerated: false,
        version: 1
      }
    };

    this.taxonomyTree.set(categoryId, category);
    parent.children.push(categoryId);

    // Create relationship
    this.relationships.push({
      source: parentId,
      target: categoryId,
      type: 'parent-child',
      strength: 100
    });

    // Record evolution
    this.evolutionHistory.push({
      timestamp: new Date(),
      action: 'created',
      nodeId: categoryId,
      newState: category,
      reasoning: `Category ${name} created under ${parent.name}`
    });

    await this.saveTaxonomy();

    console.log(`   ‚úì Category created: ${categoryId}\n`);
    return category;
  }

  async addConceptToCategory(
    concept: ConceptNode,
    categoryId: string
  ): Promise<void> {
    const category = this.taxonomyTree.get(categoryId);
    if (!category) {
      throw new Error(`Category ${categoryId} not found`);
    }

    console.log(`üîñ Adding concept "${concept.name}" to ${category.name}`);

    // Create concept node
    const conceptNode: TaxonomyNode = {
      id: concept.id,
      name: concept.name,
      type: 'concept',
      parentId: categoryId,
      children: [],
      level: category.level + 1,
      description: concept.description,
      documentCount: concept.documentReferences.length,
      conceptCount: 0,
      metadata: {
        created: new Date(),
        lastUpdated: new Date(),
        autoGenerated: true,
        version: 1
      }
    };

    this.taxonomyTree.set(concept.id, conceptNode);
    category.children.push(concept.id);
    category.conceptCount++;

    // Create relationship
    this.relationships.push({
      source: categoryId,
      target: concept.id,
      type: 'parent-child',
      strength: 100
    });

    // Add related concept relationships
    for (const relatedName of concept.relatedConcepts) {
      const relatedId = `concept-${relatedName.toLowerCase().replace(/\s+/g, '-')}`;
      if (this.taxonomyTree.has(relatedId)) {
        this.relationships.push({
          source: concept.id,
          target: relatedId,
          type: 'related',
          strength: 70
        });
      }
    }

    await this.saveTaxonomy();

    console.log(`   ‚úì Concept added\n`);
  }

  async evolveTaxonomy(documents: Document[], concepts: ConceptNode[]): Promise<void> {
    if (!this.autoEvolve) {
      console.log('‚è∏Ô∏è  Auto-evolution disabled\n');
      return;
    }

    console.log(`üå± Evolving taxonomy with ${documents.length} documents and ${concepts.length} concepts...`);

    // Step 1: Analyze document categories
    const categories = [...new Set(documents.map(d => d.category))];
    
    for (const category of categories) {
      const categoryId = `cat-${category.toLowerCase().replace(/\s+/g, '-')}`;
      
      if (!this.taxonomyTree.has(categoryId)) {
        await this.createCategory(category, 'root', `Auto-generated category for ${category}`);
      }
    }

    // Step 2: Add concepts to appropriate categories
    for (const concept of concepts) {
      if (!this.taxonomyTree.has(concept.id)) {
        // Find best category for concept
        const bestCategory = this.findBestCategory(concept);
        await this.addConceptToCategory(concept, bestCategory);
      }
    }

    // Step 3: Identify redundant categories
    await this.identifyRedundancy();

    // Step 4: Update document counts
    await this.updateDocumentCounts(documents);

    // Step 5: Generate knowledge graph
    await this.generateKnowledgeGraph();

    console.log(`   ‚úì Taxonomy evolution complete\n`);
  }

  private findBestCategory(concept: ConceptNode): string {
    // Try to match concept category to taxonomy category
    const categoryId = `cat-${concept.category.toLowerCase().replace(/\s+/g, '-')}`;
    
    if (this.taxonomyTree.has(categoryId)) {
      return categoryId;
    }

    // Find category with similar concepts
    for (const [id, node] of this.taxonomyTree.entries()) {
      if (node.type === 'category' && node.conceptCount > 0) {
        // Check if any child concepts are related
        for (const childId of node.children) {
          const child = this.taxonomyTree.get(childId);
          if (child && concept.relatedConcepts.includes(child.name)) {
            return id;
          }
        }
      }
    }

    // Default to root
    return 'root';
  }

  private async identifyRedundancy(): Promise<void> {
    console.log(`   Checking for redundant categories...`);

    const categories = Array.from(this.taxonomyTree.values())
      .filter(n => n.type === 'category' || n.type === 'subcategory');

    for (let i = 0; i < categories.length; i++) {
      for (let j = i + 1; j < categories.length; j++) {
        const cat1 = categories[i];
        const cat2 = categories[j];

        // Check name similarity
        const similarity = this.calculateStringSimilarity(cat1.name, cat2.name);
        
        if (similarity > 0.8 && cat1.level === cat2.level) {
          console.log(`   ‚ö†Ô∏è  Found similar categories: ${cat1.name} & ${cat2.name} (${Math.round(similarity * 100)}%)`);
          
          // Suggest merge (in production, would execute automatically)
          console.log(`   üí° Suggest merging into: ${cat1.name}`);
        }
      }
    }
  }

  private calculateStringSimilarity(str1: string, str2: string): number {
    const words1 = new Set(str1.toLowerCase().split(/\s+/));
    const words2 = new Set(str2.toLowerCase().split(/\s+/));
    
    const intersection = new Set([...words1].filter(w => words2.has(w)));
    const union = new Set([...words1, ...words2]);
    
    return intersection.size / union.size;
  }

  private async updateDocumentCounts(documents: Document[]): Promise<void> {
    // Reset all counts
    for (const node of this.taxonomyTree.values()) {
      node.documentCount = 0;
    }

    // Update counts based on documents
    for (const doc of documents) {
      const categoryId = `cat-${doc.category.toLowerCase().replace(/\s+/g, '-')}`;
      const category = this.taxonomyTree.get(categoryId);
      
      if (category) {
        category.documentCount++;
        
        // Propagate count up the tree
        let current = category;
        while (current.parentId) {
          const parent = this.taxonomyTree.get(current.parentId);
          if (parent) {
            parent.documentCount++;
            current = parent;
          } else {
            break;
          }
        }
      }

      // Update concept references
      for (const tag of doc.tags) {
        const conceptId = `concept-${tag.toLowerCase().replace(/\s+/g, '-')}`;
        const concept = this.taxonomyTree.get(conceptId);
        if (concept) {
          concept.documentCount++;
        }
      }
    }
  }

  async generateKnowledgeGraph(): Promise<KnowledgeGraph> {
    console.log(`üï∏Ô∏è  Generating knowledge graph...`);

    const graph: KnowledgeGraph = {
      nodes: this.taxonomyTree,
      relationships: this.relationships,
      depth: this.calculateMaxDepth(),
      totalNodes: this.taxonomyTree.size,
      totalConcepts: this.countConceptNodes()
    };

    // Save graph in multiple formats
    await this.saveKnowledgeGraph(graph);

    console.log(`   Nodes: ${graph.totalNodes}`);
    console.log(`   Concepts: ${graph.totalConcepts}`);
    console.log(`   Max depth: ${graph.depth}`);
    console.log(`   ‚úì Knowledge graph generated\n`);

    return graph;
  }

  private calculateMaxDepth(): number {
    let maxDepth = 0;
    for (const node of this.taxonomyTree.values()) {
      if (node.level > maxDepth) {
        maxDepth = node.level;
      }
    }
    return maxDepth;
  }

  private countConceptNodes(): number {
    return Array.from(this.taxonomyTree.values())
      .filter(n => n.type === 'concept').length;
  }

  async searchTaxonomy(query: string): Promise<TaxonomyNode[]> {
    const queryLower = query.toLowerCase();
    const results: TaxonomyNode[] = [];

    for (const node of this.taxonomyTree.values()) {
      if (node.name.toLowerCase().includes(queryLower) ||
          node.description.toLowerCase().includes(queryLower)) {
        results.push(node);
      }
    }

    return results.sort((a, b) => b.documentCount - a.documentCount);
  }

  async getNodePath(nodeId: string): Promise<TaxonomyNode[]> {
    const path: TaxonomyNode[] = [];
    let current = this.taxonomyTree.get(nodeId);

    while (current) {
      path.unshift(current);
      if (current.parentId) {
        current = this.taxonomyTree.get(current.parentId);
      } else {
        break;
      }
    }

    return path;
  }

  async getChildren(nodeId: string, depth: number = 1): Promise<TaxonomyNode[]> {
    const node = this.taxonomyTree.get(nodeId);
    if (!node) return [];

    const children: TaxonomyNode[] = [];

    for (const childId of node.children) {
      const child = this.taxonomyTree.get(childId);
      if (child) {
        children.push(child);
        
        if (depth > 1) {
          const grandchildren = await this.getChildren(childId, depth - 1);
          children.push(...grandchildren);
        }
      }
    }

    return children;
  }

  async exportTaxonomyMarkdown(): Promise<string> {
    let markdown = '# Knowledge Taxonomy\n\n';
    markdown += `Generated: ${new Date().toISOString()}\n\n`;
    markdown += `Total Nodes: ${this.taxonomyTree.size}\n`;
    markdown += `Total Concepts: ${this.countConceptNodes()}\n`;
    markdown += `Max Depth: ${this.calculateMaxDepth()}\n\n`;

    markdown += '---\n\n';

    // Render tree starting from root
    const root = this.taxonomyTree.get('root');
    if (root) {
      markdown += this.renderNodeMarkdown(root, 0);
    }

    const mdPath = path.join(this.outputDir, 'taxonomy.md');
    await fs.writeFile(mdPath, markdown, 'utf-8');

    return markdown;
  }

  private renderNodeMarkdown(node: TaxonomyNode, indent: number): string {
    let md = '';
    const prefix = '  '.repeat(indent);

    if (node.type === 'root') {
      md += `${'#'.repeat(indent + 1)} ${node.name}\n\n`;
    } else if (node.type === 'concept') {
      md += `${prefix}- **${node.name}** (${node.documentCount} docs)\n`;
      if (node.description) {
        md += `${prefix}  - ${node.description}\n`;
      }
    } else {
      md += `${'#'.repeat(indent + 2)} ${node.name}\n\n`;
      md += `${prefix}Documents: ${node.documentCount} | Concepts: ${node.conceptCount}\n\n`;
      if (node.description) {
        md += `${prefix}${node.description}\n\n`;
      }
    }

    // Render children
    for (const childId of node.children) {
      const child = this.taxonomyTree.get(childId);
      if (child) {
        md += this.renderNodeMarkdown(child, indent + 1);
      }
    }

    return md;
  }

  private async loadTaxonomy(): Promise<void> {
    try {
      const taxonomyPath = path.join(this.outputDir, 'taxonomy.json');
      const content = await fs.readFile(taxonomyPath, 'utf-8');
      const data = JSON.parse(content);

      if (data.nodes) {
        for (const node of data.nodes) {
          this.taxonomyTree.set(node.id, node);
        }
      }

      if (data.relationships) {
        this.relationships = data.relationships;
      }

      if (data.evolution) {
        this.evolutionHistory = data.evolution;
      }
    } catch {
      // No existing taxonomy to load
    }
  }

  private async saveTaxonomy(): Promise<void> {
    const data = {
      nodes: Array.from(this.taxonomyTree.values()),
      relationships: this.relationships,
      evolution: this.evolutionHistory,
      metadata: {
        lastUpdated: new Date(),
        totalNodes: this.taxonomyTree.size,
        totalConcepts: this.countConceptNodes(),
        maxDepth: this.calculateMaxDepth()
      }
    };

    const taxonomyPath = path.join(this.outputDir, 'taxonomy.json');
    await fs.writeFile(taxonomyPath, JSON.stringify(data, null, 2), 'utf-8');

    // Create snapshot
    const snapshotPath = path.join(
      this.outputDir,
      'snapshots',
      `taxonomy-${Date.now()}.json`
    );
    await fs.writeFile(snapshotPath, JSON.stringify(data, null, 2), 'utf-8');
  }

  private async saveKnowledgeGraph(graph: KnowledgeGraph): Promise<void> {
    // Save as JSON
    const graphPath = path.join(this.outputDir, 'graphs', 'knowledge-graph.json');
    await fs.writeFile(graphPath, JSON.stringify({
      nodes: Array.from(graph.nodes.values()),
      relationships: graph.relationships,
      metadata: {
        depth: graph.depth,
        totalNodes: graph.totalNodes,
        totalConcepts: graph.totalConcepts
      }
    }, null, 2), 'utf-8');

    // Save as DOT format for Graphviz
    await this.exportGraphvizDOT(graph);

    // Save as Markdown
    await this.exportTaxonomyMarkdown();
  }

  private async exportGraphvizDOT(graph: KnowledgeGraph): Promise<void> {
    let dot = 'digraph KnowledgeGraph {\n';
    dot += '  node [shape=box, style=filled];\n';
    dot += '  rankdir=TB;\n\n';

    // Add nodes
    for (const node of graph.nodes.values()) {
      const color = node.type === 'root' ? 'lightblue' :
                   node.type === 'category' ? 'lightgreen' :
                   node.type === 'subcategory' ? 'lightyellow' : 'pink';
      
      dot += `  "${node.id}" [label="${node.name}\\n(${node.documentCount} docs)", fillcolor="${color}"];\n`;
    }

    dot += '\n';

    // Add relationships
    for (const rel of graph.relationships) {
      const style = rel.type === 'parent-child' ? 'solid' : 'dashed';
      dot += `  "${rel.source}" -> "${rel.target}" [style=${style}];\n`;
    }

    dot += '}\n';

    const dotPath = path.join(this.outputDir, 'graphs', 'knowledge-graph.dot');
    await fs.writeFile(dotPath, dot, 'utf-8');
  }

  getNode(id: string): TaxonomyNode | undefined {
    return this.taxonomyTree.get(id);
  }

  getAllNodes(): TaxonomyNode[] {
    return Array.from(this.taxonomyTree.values());
  }

  getRelationships(nodeId?: string): TaxonomyRelationship[] {
    if (!nodeId) return this.relationships;
    
    return this.relationships.filter(
      r => r.source === nodeId || r.target === nodeId
    );
  }

  getEvolutionHistory(nodeId?: string): TaxonomyEvolution[] {
    if (!nodeId) return this.evolutionHistory;
    return this.evolutionHistory.filter(e => e.nodeId === nodeId);
  }

  setAutoEvolve(enabled: boolean): void {
    this.autoEvolve = enabled;
    console.log(`‚ôªÔ∏è  Auto-evolution ${enabled ? 'enabled' : 'disabled'}\n`);
  }
}
